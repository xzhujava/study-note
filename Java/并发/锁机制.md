锁机制基础
---
### 锁的分类
**从宏观上可分为：悲观锁、乐观锁两种**
#### 悲观锁
悲观锁就是悲观思想，认为写多读少，遇到并发写的可能性高。每次去拿数据都会认为别人会修改，所以每次在读写数据时都会上锁，这样别人想读写数据就会阻塞(bolck)直到拿到锁

java中的悲观锁就是Synchronize、AQS框架下的锁则是先尝试CAS乐观锁去获取锁，**获取不到才会转换为悲观锁**，如：ReentrantLock。
#### 乐观锁
乐观锁是一种乐观思想，认为读多写少，遇到并发写的可能性低。每次去拿数据都不会认为别人会修改数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。

java中的乐观锁基本都是通过CAS操作实现的，**CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。**

#### i=0,i++问题

##### i++步骤
CPU拿到->CPU运算+1->放回主存

##### i++执行10000次，多线程会发生什么？
因为i++不是原子操作，多线程执行会引发并发问题(线程安全问题)
##### 如何解决
**加锁：**
1. synchronized(悲观锁)
    
    未获取锁的线程会阻塞等待
2. CAS(乐观锁)
    
    优点：不会阻塞线程，自旋重试，减少线程上下文切换带来的开销
    
    缺点：占用cpu，有可能会失败

### Java中的锁
#### 偏向锁
> Java偏向锁(Biased Locking)是Java1.6引入的一项多线程优化，它通过消除资源无竞争情况下的同步原语，进一步提高程序的运行性能

**偏向锁，顾名思义它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。**
如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。
##### 偏向锁获取过程
1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。
2. 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。
3. 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。
4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the world）
5. 执行同步代码。

**注意：** 第四步中到达安全点safepoint会导致stop the world，时间很短

#### 偏向锁、轻量级锁、重量级锁，锁升级过程
无锁->偏向锁->轻量级锁->重量级锁

    
